# [A Full RNS Variant of Approximate Homomorphic Encryption](https://eprint.iacr.org/2018/931)

## 記法
- $[x]_y$ を $x$ を $y$ で割った余りで $-y/2$ より大きく $y/2$ より小さいとする。
- 相異なる素数の集合 $\cal{B} := \Set{p_i}$ について $P:=\prod_i p_i$ とおく。
$a \in Z/PZ$ に対して $[a]_{\cal{B}}:=(a \bmod{p_i})_i$ を $a$ の $\cal{B}$ に関するRNS表現と呼ぶ。
## CRTの復習

方程式 $x \equiv a_i \pmod{p_i}$（ $p_i$ は $n$ 個の相異なる素数）

$P:=\prod_i p_i$, $\hat{p}_i := P/p_i$ とおく。
$p_i$ と $\hat{p}_i$ は互いに素なので $\hat{p}_i r_i \equiv 1 \pmod{p_i}$ となる $r_i$ が存在する。
以降、この $r_i$ を $\hat{p}_i^{-1}$ と書く。
$X := \sum_i a_i \hat{p}_i^{-1} \hat{p}_i$ とおく。
$i \neq j$ なら $\hat{p}_i$ は $p_j$ で割り切れるので、 $\pmod{p_j}$ で $X \equiv a_j \hat{p}_j^{-1} \hat{p}_j \equiv a_j$ となり、 $X$ は解である。
$X$ の代わりに $X':=\sum_i [a_i \hat{p}_i^{-1}]_{p_i} \hat{p}_i$ としても同様の理由で $X'$ は解である。$X'$ を $X$ と置き直す。 $a := X \bmod{P}$ とする。

$|[\cdot]_{p_i}| \le p_i/2$ なので $|X| \le \sum_i p_i/2 (P/p_i) = (n/2)P$ となる。
$X=a+Pe$, $|a+Pe| \le (n/2)P$ となる($/n2$ より)小さな $e$ が存在する。

### 実装

補助関数
- `invMod(x, m)` : $x$ の $m$ に関する逆元を返す。
- `mod(x, p)` : $x$ を $p$ で割った余りを返す。範囲は`[-p//2,p//2]`

```python
def invMod(x, m):
  return pow(x, -1, m)

def mod(x, p):
  r = x % p
  if MOD_HALF:
    if r > p//2:
      r -= p
  return r
```

`ss`を相異なる素数のリストとしたとき、`split(x, ss)`は`x in [0, prod(ss)]`に対して`[x mod ss[i]]`を返す。
```python
def split(x, ss):
  """
  return [x mod ss[i]]
  """
  r = []
  for p in ss:
    r.append(mod(x, p))
  return r
```

`CRT(xs, ss)`は`xs`を`ss[i]`で割った余りが`xs[i]`であるような`x`を返す関数である。
```python
def CRT(xs, ss):
  """
  recover x from xs
  return x such that x mod ss[i] = xs[i]
  """
  assert(len(xs) == len(ss))
  s = prod(ss)
  x = 0
  for i in range(len(xs)):
    m = s//ss[i]
    r = invMod(m, ss[i])
    # r * ss[i] = 1 mod s//ss[i]
    v = xs[i]
    x += r * m * v
  return x % s
```

## Fast Basis Conversion
$\cal{B}=\Set{p_0, \cdots, p_{k-1}}$, $\cal{C}=\Set{q_0, \cdots, q_{l-1}}$ とおく。これらは互いに素であるとする。 $P:=\prod_i p_i$, $Q:=\prod_j q_j$ とおく。 $a \in Z/QZ$ に対して $[a]_{\cal{C}}:=(a^{(0)}, \cdots, a^{(l-1)})$ を $\cal{C}$ に関するRNS表現とする。
$\hat{q}_j:=Q/q_j$ とする。

$$
X:=\sum_{j=0}^{l-1} [a^{(j)} \hat{q}_j^{-1}]_{q_j} \hat{q}_j,\\
Conv_{\cal{B} → \cal{C}}(a) := [X]_{\cal{B}}
$$
とする。上記と同様の理由で $X=a+Qe$, $|a+Qe| \le (l/2)Q$ となる小さな $e$ が存在する。

$Conv_{\cal{B} → \cal{C}}(a)$ は $X=a+Qe$ の $\cal{B}$ に関するRNS表現である。

```python
def conv(xs, C, B):
  """
  change base from C to B
  xs = split(x, C)
  X = x + Qe where e is small
  return split(X, B)
  """
  assert(len(xs) == len(C))
  Q = prod(C)
  X = 0
  for i in range(len(C)):
    q_hat = Q//C[i]
    r = invMod(q_hat, C[i])
    c = mod(xs[i]*r, C[i])
    X += c * q_hat
  return split(X, B)
```
## modUp
$a \in Z/QZ$ のRNS表現 $[a]_{\cal{C}}$ に対して $\tilde{a} \equiv a \pmod{Q}$ で $|\tilde{a}| \ll PQ$ となる $\tilde{a}$ を構成する。
`ys=conv(xs, C, B)` は $\tilde{a}:=x + Qe$ の $\cal{B}$ に関するRNS表現なので、 `ys cup xs` は $\cal{D}$ に関するRNS表現で求めるものとなる。

```python
def modUp(xs, C, B):
  """
  change base from C to B + C
  xs = split(x, C)
  return split(x, B + C)
  """
  assert(len(xs) == len(C))
  ys = conv(xs, C, B)
  return ys + xs
```

## modDown
$\tilde{b} \in Z/PQ Z$ のRNS表現 $[\tilde{b}]_{\cal{D} \cup \cal{C}}$ に対して $b \in Z/QZ$ で $b \approx P^{-1}\tilde{b}$ なるものを構成する。

$\tilde{b}$ を $P$ で割った余りを $a$, 商を $c$ とする。すなわち $\tilde{b} = a + Pc.$
まず $[\tilde{b}]$ の前半 $k$ 個を使って`zs=conv(ys[:k], B, C)`とする。`zs`は $\tilde{a}:=a+Pe$ の $\cal{B}$ に関するRNS表現である（ $e$ は小さい値）。
$P$ の $q_j$ に関する逆元を $P^{-1}$ として $b^{(j)}:=P^{-1}(\tilde{b}^{(k+j)} - \tilde{a}^{(j)}) \bmod{q_j}$ とする。これは $P^{-1}(\tilde{b} - \tilde{a})=c-e \approx c$ の $\cal{C}$ に関するRNS表現となっている。

```python
def modDown(ys, C, B):
  """
  change base from B + C to C
  y = CRT(ys, B + C)
  return split(y/P, C)
  """
  K = len(B)
  L = len(C)
  zs = conv(ys[:K], B, C)
  P = prod(B)
  ret = []
  for i in range(L):
    r = invMod(P, C[i])
    r = (ys[K+i] - zs[i]) % C[i]
    ret.append(r)
  return ret
```

## 計算コスト
$\cal{B}$ や $\cal{C}$ の各要素をCPUのワードサイズに納まるようにする。
$\hat{q}_j^{-1}$ や $P^{-1} \bmod{q_j}$ などは事前計算できる。よってmodUpやmodDownの計算コストは $O(kl)$ となる。