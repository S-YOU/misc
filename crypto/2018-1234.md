# [FACCT: FAst, Compact, and Constant-Time Discrete Gaussian Sampler over Integers](https://eprint.iacr.org/2018/1234)

## 概要
- 格子ベース暗号では離散ガウスサンプリングが必要
- 従来の実装はコンスタントタイムではないのでサイドチャネル攻撃の可能性
- 既存の定数時間アルゴリズムは速度とメモリが非効率
  - σ:離散ガウス分布の標準偏差
  - τ:テールカット係数(10~12)とするとテーブルサイズはO(τσ)
  -  ベースサンプラーを利用する
    - ずっと小さな標準偏差σ_0からサンプルを生成する
    - エキスパンダを利用してこれらのサンプルを統合してより大きなσのサンプルを生成する
    - コンボリューションのレベルをlとすると2^l回のベースサンプラーが必要

## 貢献
- 注意深く選択した多項式近似でexp(x)を高い精度で計算する
  - exp(x)を事前計算したりBernoulliサンプルを組み合わせたりしない
- バイナリサンプリングエクスパンダをコンパクトな定数時間実装にする
- Renyi発散をバイナリサンプリングに適用する
- 他の手法より効率的であることを示す
- 提案手法は標準偏差に依存しない
- 既存手法に比べてRenyi発散を畳み込みサンプリングに適用するときにベースサンプラーσ_0を小さくできる

## 準備
- $ρ_σ(x) = exp(-x^2/2σ^2)$ : 平均0、標準偏差σの(連続な)ガウス関数
- $D_σ(x) = ρ_σ(x)/\sum_{k \in Z} ρ_σ(k)$ : 離散ガウス分布
- $U(S)$ : 集合Sの一様分布
- $B_p$ : バイアスpのBernoulli分布 $Pr(X=1)=p$, $Pr(X=0) = 1-p$
- ある区間 $[-B, B]$ に制約した分布をB-boundedという
- 格子 Λ と ε ∈ $R^+$ に対して $η_ε(Λ)$ を $ρ_{1/(s \sqrt{2π})}$ $(Λ^* - \set{0})≦ ε$ となる一番小さいsとする
  - ただし $Λ^*=\set{w ∈ R^n | x w ∈ Z \text{ for all } x ∈ Λ}$.
  - $η_ε(Z) \le \sqrt{\ln(2+2/ε)/π}$

- P, QはSupp(P) = Supp(Q)となる分布
- PとQの相対誤差Δ(P|Q) = $\max_{x∈Supp(P)} (|P(x)-Q(x))|/Q(x)$
- Kullback Leibler距離KL(P|Q) = $\sum_{x∈Supp(P)} P(x)\log(P(x)/Q(x))$
- Renyi発散
  - $R_α(P|Q) = (\sum_{x∈Supp(P)} P(x)^α/Q(x)^{α-1})^{1/(α-1)}$ for $α \ge 1$
  - $R_∞(P|Q)=\max_{x∈Supp(P)}P(x)/Q(x)$
- Max-log距離 $ML(P|Q)=\max_{x∈Supp(P)}|\log P(x)-\log Q(x)|$

### 定理
$D'_σ$ を $D_σ$ のB-bounded分布とするとM個の独立なサンプルに対して

$R_∞((D'_σ)^M|(D_σ)^M)\le exp(1)$ if $B \ge σ\sqrt{2 \log(2M)}$

## バイナリサンプリング法

- $σ=kσ_0$, $k \in Z^+$, $σ_0 = \sqrt{1/(2\log 2)}$
- $D_{σ_0}^+$ から $x$, $U(\set{0, \dots, k-1})$ から $y$ をサンプリング
- 受理率 $p=exp((-y(y+2kx)/2σ^2))$ で $z=kx+y$ を棄却サンプリングする
- 符号は符号ビットをランダムに選ぶ

確率は

$ρ_{σ_0}p=\exp(-x^2/2σ_0^2+(-y(y+2kx)/2(kσ_0)^2))=\exp(-(kx+y)^2/2(kσ_0)^2)=ρ_{kσ_0}(z)=ρ_σ(x)$

### $D_{σ_0}^+$ からのサンプリング方法
- $b ← U(\set{0,1})$
- $b = 0$ ならreturn0
- $i ← 1$
  1. $(b_1,b_2,\dots, b_{2i-1}) ← U(\set{0,1})^{2i-1}$
  1. $(b_1,b_2,\dots, b_{2i-2}) \neq (0,\dots, 0)$ ならやり直し
  1. $b_{2i-1}=0$ なら return i
  1. $i ← i + 1$ として 1. に戻る

### ベースサンプラー

- $t=y(y+2kx)$, $0 \le t < 2^l$
- $t=t_{l-1}\dots t_0$ 2進数表記
- $x ← D_{σ_0}^+$, $y ← U(\set{0, \dots, k-1})$
- $B_p$ : Bernoulli分布, $p=exp(-t/2σ^2)$
- $p_i = exp(-2^i/2σ^2)$ for $i < l$
- for $i=l-1, l-2, \dots, 0$
  - $t_i = 1$ なら $a ← B_p$
    - $a = 0$ なら return 0
- return 1

定数時間版

- $r ← 1$
- For $i=l-1, l-2, \dots, 0$
  - $a ← B_{p_i}$
  - $r ← r(1-t_i(1-a))$
- return r

定数時間実装でない場合、サイドチャネル攻撃で離散ガウスベクトルや中間のサンプルを収集して署名鍵を復元できる可能性

既存の対策
- Fisher-YatesランダムシャッフルやKnuthシャッフル
  - 攻撃ベクトルの中の統計的特徴を完全には隠せない

累積分布テーブルサンプラー(CDT : Cumulative Distribution Table)
- $(O\log B)$ の定数回数でCDTをバイナリサーチする
- メモリアクセスは定数ではないのでキャッシュタイミング漏洩の可能性

提案する定数時間実装

- Bernoulliバイアスpはdoubleの精度で直接計算できる
- Intel CPU上で除算は定数時間ではないので避ける
- exp(x)のPade近似を使う
- $u < P(x)/Q(x)$ の棄却ステップの代わりに $uQ(x) < P(x)$ を使う


適用方法
- $t = y(y+2kx)$, $σ_0 = \sqrt{1/(2 \log 2)}$, $σ = k σ_0$
- $p = exp(-t/2σ^2)=exp(-\log 2 t / k^2) = 2^{-t/k^2}$
  - この近似計算をすればよい
- $a = -t/k^2$
  - $2^a = 2^{floor(a)+z} = 2^{floor(a)} 2^z$, where $0 \le z < 1$.

### exp(x)の近似計算
- Input : x s.t. $|x| \le \log 2$
- Output : exp(x) 50-bit精度
- $p_1, p_2, \dots, p_5$ : constatnt
- $s ← x/2$
- $t ← s^2$
- $c ← = s - t(p_1 + t(p_2 + t(p_3 + t(p_4+t p_5))))$
- $r ← 1 - ((sc)/(c-2)-s)$
- return $r^2$

### FACCTアルゴリズム
Input
- $σ = kσ_0$, $k \in Z^+$, $σ_0= \sqrt{1/(2\log 2)}$, $t = y(y+2kx)$, $x ← D_{σ_0}^+$, $y ← U(\set{0, \dots, k-1})$
- $P(z)$ : $2^z$ の近似多項式 $0 \le z < 1$, $l> 2B+1$
Output
- $B_p$, $p=exp(-t/2σ^2)=2^{-t/k^2}$ からのサンプル
- $a ← -t/k^2$
- $z ← a - floor(a)$
- $s ← P(z)$
- $f ← s 2^{floor(a)}$
  - $f = (1+mantissa \cdot 2^{-δ_f})2^{exponent}$ と表現する
  - $r_m ← U(\set{0, 1}^{δ_f+1})$
  - $r_e ← U(\set{0,1}^l)$
  - if $(r_m < mantissa + 2^{δ_f})$ and $r_e < 2^{l + exponent+1}$ or $f = 1$ return 1
  - return 0

比較
  - 従来のテーブルを用いた定数時間サンプリングに比べてメモリ消費量が少ない(21→9)
  - σ に依存しないので大きな標準偏差に対してより効率的
  - ビットスライシングコンボリューション方式の2倍高速


## exp(x)

- $e^x = 1 + x + x^2/2! + x^3/3! + ...$.
- $e^x = 2^{x \log_2(e)}$.
  - $x'=x \log_2(e)=n + a$,  where $n = \text{round}(x') \in Z$, $|a| \le 1/2$.
- $e^x = 2^{x'} = 2^n 2^a$.
- $2^a = e^{a \log(2)}$.
  - $b = a \log(2)$ とすると $|b| \le C = \log(2)/2 \approx 0.346$.

### float/doubleの分解能

- float : `FLT_EPS` = $1/2^{23} \approx 1.19\cdot 10^{-7}$.
  - $C^n/n! < $ `FLT_EPS` となる最小の $n$ は 7.
- double : `DBL_EPS` = $1/2^{52} \approx 2.22\cdot 10^{-16}$.
  - $C^n/n! < $ `DBL_EPS` となる最小の $n$ は 13.

### 多項式近似の精度向上

Sollya
- [guessdegree](https://www.sollya.org/sollya-3.0/help.php?name=guessdegree)
- [fpminimax](https://www.sollya.org/sollya-3.0/help.php?name=fpminimax)
- [dirtyinfnorm](https://www.sollya.org/sollya-3.0/help.php?name=dirtyinfnorm)

```
L=log(2)/2;
R=[-L,L];
guessdegree(exp(x),R, 1b-23);
P=fpminimax(exp(x),[|1,2,3,4,5|],[|1,D...|],R,1);
dirtyinfnorm(P-exp(x),R);
>P;
1 + x * (1 + x * (0.49999140104492290070936633128440007567405700683594 + x * (0.166668484404639632989741926394344773143529891967773 + x * (4.1898828262521441156973622810255619697272777557373e-2 + x * 8.3374335295377643290093416794661607127636671066284e-3))))

> 1.18569705667671607792094761868203739928409159514397e-7
```
- guessdegreeで必要な次数を取得する。=> 5
- fpminmaxで禁じた公式を得る。最後の「1」は「$1+x+ax^2+...$」
の形にしたいため。不要なら

```
fpminimax(exp(x),5,[|1,D...|],[-log(2)/2;log(2)/2]);
```
でもよい。

dirtyinfnormで区間の最大誤差を得る。

float版
```
```

double版
```
L=log(2)/2;
R=[-L,L];
guessdegree(exp(x),R, 1b-52);
[10:11]

P10=fpminimax(exp(x),[|1,2,3,4,5,6,7,8,9,10|],[|1,double...|],R,1);
dirtyinfnorm(P10-exp(x),R);
P11=fpminimax(exp(x),[|1,2,3,4,5,6,7,8,9,10,11|],[|1,double...|],R,1);
dirtyinfnorm(P11-exp(x),R);
P13=fpminimax(exp(x),[|1,2,3,4,5,6,7,8,9,10,11,12,13|],[|1,double...|],R,1);
dirtyinfnorm(P13-exp(x),R);

> P10;
1 + x * (1 + x * (0.49999999999996652677580755153030622750520706176758 + x * (0.16666666666609067370963259691052371636033058166504 + x * (4.1666666669210782047994001686674891971051692962646e-2 + x * (8.3333333718410250445796094709294266067445278167725e-3 + x * (1.38888882843871889864739710418461982044391334056854e-3 + x * (1.98411840563258735350635197924873409647261723876e-4 + x * (2.48021374984521355568610478936619756495929323136806e-5 + x * (2.763544540735521576004960972450241740716592175886e-6 + x * 2.7412142606349650815863094530100418921847449382767e-7)))))))))

> 4.2526838485159087152836195254711308283167262769438e-16
> 4.4126109943546505403641077826013087036622885441725e-18
> 4.7614346463504284219318158047898510771487379322839e-21
```
10次でよさそう。
