<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="ja"><head><title>report</title>
<meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS"></head><body>
<h1>配列の拡張</h1>

<dl>
	<dt>core
	<dd><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3639.html">N3639 Runtime-sized arrays with automatic storage duration</a>
	<dt>lib
	<dd><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3662.html">N3662 C++ Dynamic Arrays</a>
	<dt>全体
	<dd><a href="http://isocpp.org/files/papers/n3820.html">N3820 : Working Draft, Technical Specification - Array Extensions</a>
</dl>

細かいところで上記に書かれていることが違っていたりする(配列が0サイズを許すか否かなど)。
最終的な規格がどう決まるか注意が必要。

<h2>core</h2>
coreは実行時に長さが確定する配列(array of runtime bound : 以降ARBと略す)の機能を提供する。
これはC99のVLA(variable length array)と似ているが同じものではない。

<pre>
void f(int n)
{
    int a[n];
}
</pre>

<h3>ARBの特徴</h3>
<ul>
	<li>literal型でない
	<li>pointer型に変換できる
	<li>initializer list対応
	<li>template parameterになれない
	<li>copyキャプチャされない
	<li>参照キャプチャされたときはもとのサイズ情報を保持する
	<li>typeid不可
	<li>decltype(ARB)不可
	<li>ARBの参照不可
</ul>
<h3>VLAとの違い(N3639)</h3>
ARBは
<ul>
	<li>トップ以外のサイズが実行時に決まるような多次元配列の非サポート
	<li>関数宣言の文法を変えない
	<ul>
		<li>void f(int n, int a[n][n]);はC99ではOKだがC++では駄目
	</ul>
	<li>sizeof禁止
	<li>typedef int a[n];の禁止
</ul>

<h2>std::dynarray&lt;T&gt;</h2>
実行時にサイズを決められるstd::arrayのようなもの。
可能ならstack上に配列を構築する。無理ならheapにとる配列のクラス。
領域は連続して確保される。

<pre>
std::dynarray&lt;T&gt; a(n);のとき
a.data() + i == &amp;a[0] + i for 0 &lt;= i &lt; n
</pre>

<ul>
	<li>Tはcopy cstrを持たなければならない
	<li>T&amp;&amp;のcstrを持たない
	<li>swapは持たない
	<li>data()メソッドでT*を取得できる
	<li>size=0は可能。ただしdata()の値はundefined
	<li>resizeできない
	<li>オブジェクトがstackにとられたかheapにとられたか知る方法を提供しない
	<li>fill()を持つ
</ul>

<h2>VLAとARBとdynarrayの比較</h2>
<table border="1" summary="compare">
<tr><td></td><td>C99のVLA</td><td>ARB</td><td>dynarray</td></tr>
<tr><td>sizeof</td><td>実行時のsizeof可能</td><td>エラー</td><td>意味がない</td></tr>
<tr><td>size=0</td><td>undefined(6.7.5.2の5:it shall have a value greater than zero)</td><td>N3639ではエラー N3820では記載なし</td><td>N3662ではエラー N3820ではOK</td></tr>
<tr><td>size&lt;0</td><td>undefined(6.7.5.2とp.506)<td>N3820 ill-formed</td><td>-</td></tr>
<tr><td>メモリ確保できないとき</td><td>?</td><td>undefined. bad_array_lengthをthrowするのが望ましい</td><td>bad_array_length</td></tr>
</table>

サイズの正負はsize_tにキャスとする前の値で決められる。

<h2>コンパイラの対応状況</h2>
<dl>
	<dt>ARB
	<dd>gcc 4.8.1, clang 3.4は対応している。ただしVLAの挙動に近い。
	sizeofやtypedefが可能。値を大きくとってもbad_array_lengthは投げられない。オブジェクトは生成されるが実際に値を書き込みにいったところでSEGV。
	gccには-fstack-checkオプションはあるが、これには役に立たない。<br>
	VC2013は非対応。
	<dt>dynarray
	<dd>gcc, clang, VCどれも非対応。
</dl>

</body></html>
